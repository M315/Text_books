\section{Designing interfaces}

Any project has an API. So there are some good practices that a project should follow so it can scale better and it can be used by anyone as easily as possible.

\subsection{Unsurprising}

The Principle of Least Surprise. Where possible your interfaces should be intuitive so when a user has to guess, guesses right.

\subsubsection{Naming}

The namig should be intuitive and if any name is used in more than one place it should align with each other so the user can infer what the function, type, trait… produces.

\subsubsection{Traits}

The types that the interface contains should implement a list of traits if possible so the users don't get confused by not having them:

\begin{enumerate}
    \item Debug
    \item Send \& Sync
    \item Clone \& Default
    \item PartialEq, PartialOrd, Hash, Eq, Ord
\end{enumerate}

Some might not apply but if they do, should be there. Also the interface should handle \textit{From} and \textit{Into} so the types can be \textbf{wrap} and \textbf{unwrap}.

\subsection{Flexibility}

"Each piece of code can be thought as a contract,
with a set of restrictions and promises,
where some inputs with some properties are expected and an output with some properties is returned."

A good rule of thump is not be too restrictive and only do promises you can keep.
Adding restrictions or removing promises usually breaks backward compatibility,
on the other hand, relaxing the restrictions or adding more promises tends to be more save.

Rust restrictions and promises are usually on the signature of a function,
where it is specified which type or trait should the input have and which characteristics the return will present.

\subsection{Borrowed vs. Owned}

Functions should take references unless they need the object in memory for some reason,
this helps keeping the memory more clean and do not perform unnecessary copies of memory.

\subsection{Destructors}

It should be clear who takes care of cleaning and object like a I/O stream before dropping it so the memory it occupies frees.

\subsection{Documentation}

The best thing for a project that is big enough or is shared by multiple users is to have a good documentation.

Documentation should explain the obvious things that are in the interface like types, traits, functions…
but more important it should contain all the unexpected behavior like errors…

Also it should contain no obvious examples of the interface,
so the users can start their projects with an example and modifying things until they get the result they were looking for.

\subsubsection{Type guidance}

A useful thing to do is to create dummy types to use in the function as a boolean instead of a \textit{true} or \textit{false},
so the signatures and the usage of the function is more intuitive.

For example if an input can be a string so the function does something different depending on the string,
would be interesting to have an enum with types so its more natural the options that are available.